C51 COMPILER V9.56.0.0   TASK                                                              06/09/2018 16:09:47 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE TASK
OBJECT MODULE PLACED IN task.OBJ
COMPILER INVOKED BY: F:\KEILC51+MDK\C51\BIN\C51.EXE task.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*************************************************************
   2                               时钟显示程序
   3          程序编写：Fucp   2015-5-17
   4          DIY套件  http://59tiaoba.taobao.com
   5          
   6          单片机 IAP15W4K61S4  或者其他51  晶振频率 18.432M  
   7          文字字模软件用  PC2002  图片软件用 圆形图片取模软件 
   8          逐列取模方式
   9          
  10          电机旋转方向 顺时针      
  11          /***********************************************************
  12          说明：本程序支持配套遥控器调整时间
  13          播放按键  切换调整 时、分、秒、月、日
  14          加 按键：增加
  15          减 按键：减少
  16          menu按键： 时钟复位
  17          
  18          遥控器按键1 ：平面显示文字+侧面显示时钟  可调时
  19          遥控器按键2 ：平面指针时钟+侧面显示文字
  20          *************************************************************/
  21          #include "NEW_8051.H"
  22          #include "intrins.h"
  23          #include "task.h"
  24          #define FOSC 18432000L          //系统频率
  25          #define BAUD 115200             //串口波特率
  26          bit Scan_bit=0;   
  27          uint Offset=0;//文字偏移地址
  28          uint OffsetAdder=0;//图片偏移地址
  29          bit BIT_timeout=0;
  30          uchar ucMode=2;  //图片模式
  31          bit Time0_flag=0;       //定时器T0中断标志位
  32          uchar DISP_LINE=0;
  33          uint Pt=50,S0,T,D;              //计数用的变量
  34          uchar ucAdder=0;
  35          /*********中断子程序**********/
  36          void int0() interrupt 0 //使用外部中断0
  37          {
  38   1              BIT_timeout=1; //起点标志位
  39   1              if(ucMode!=1)
  40   1              {       
  41   2      
  42   2                      D+=(DISP_LINE-180)*2;   //修正值
  43   2                      Pt=205+D; 
  44   2                  //得到定时器T0的初设值
  45   2                      TH0=-Pt/256;
  46   2                      TL0=-Pt%256;   //设置定时器T0的初设值
  47   2                      DISP_LINE=0;   //计数器清零，将重新计数
  48   2                      Offset++;
  49   2                       if(Offset>1408)//侧面有多少文字 这个值就对应改成  多少字*16 
  50   2                              Offset=0;       
  51   2              
  52   2              }
  53   1      }
  54          /******************************************/
  55          void Send_uart(unsigned char d)   /*从串口发送数据*/
C51 COMPILER V9.56.0.0   TASK                                                              06/09/2018 16:09:47 PAGE 2   

  56          {
  57   1                ES=0;
  58   1            SBUF=d;
  59   1                while(TI==0);       //等待发送完毕
  60   1            TI=0;
  61   1                ES=1;
  62   1      }
  63          /*************************************/
  64          //图片切换以及模拟表盘显示函数
  65          void display_pic()
  66          {
  67   1              uchar date1,date2,date3,date4;
  68   1              if(DISP_LINE<180)
  69   1              {
  70   2                      if(Time0_flag)
  71   2                      {
  72   3                              Time0_flag=0;
  73   3                              Close();                
  74   3                              date1=picture[DISP_LINE*4+0+OffsetAdder];
  75   3                              date2=picture[DISP_LINE*4+1+OffsetAdder];
  76   3                              date3=picture[DISP_LINE*4+2+OffsetAdder];
  77   3                              date4=picture[DISP_LINE*4+3+OffsetAdder];
  78   3                              Show_L(date1,date2,date3,date4);
  79   3                          Show_R(Lzimo[(DISP_LINE+Offset)*2],Lzimo[(DISP_LINE+Offset)*2+1]);//送16*16文字显示 
  80   3                                      
  81   3                      }
  82   2            }
  83   1      }
  84          /*********************************************/
  85          void Init(void)
  86          {
  87   1              P0M0=0X00;//初始化IO口 为准双向口
  88   1              P0M1=0X00;
  89   1      
  90   1              P1M0=0X00;
  91   1              P1M1=0X00;
  92   1      
  93   1              P2M0=0X00;
  94   1              P2M1=0X00;
  95   1      
  96   1              P3M0=0X00;
  97   1              P3M1=0X00;
  98   1      
  99   1              P4M0=0X00;
 100   1              P4M1=0X00;
 101   1      
 102   1              P5M0=0X00;
 103   1              P5M1=0X00;
 104   1      
 105   1              P6M0=0X00;
 106   1              P6M1=0X00;
 107   1      
 108   1              P7M0=0X00;
 109   1              P7M1=0X00;
 110   1      
 111   1              Show_R(0x55,0x55);//测试
 112   1              Show_L(0x55,0x55,0x55,0x55);//测试
 113   1      
 114   1      AUXR &= 0x7F;           //定时器时钟12T模式
 115   1              TMOD &= 0xF0;           //设置定时器模式
 116   1              TMOD |= 0x01;           //设置定时器模式
 117   1              TL0 = 0xCD;             //设置定时初值
C51 COMPILER V9.56.0.0   TASK                                                              06/09/2018 16:09:47 PAGE 3   

 118   1              TH0 = 0xFE;             //设置定时初值
 119   1              TF0 = 0;                //清除TF0标志
 120   1              TR0 = 1;                //定时器0开始计时
 121   1              ET0=1;
 122   1      
 123   1              AUXR &= 0xBF;           //定时器时钟12T模式
 124   1              TMOD &= 0x0F;           //设置定时器模式
 125   1              TMOD |= 0x20;           //设置定时器模式
 126   1              TL1 = 0x12;             //设置定时初值 155US
 127   1              TH1 = 0x12;             //设置定时重载值
 128   1              TF1 = 0;                //清除TF1标志
 129   1              ET1=1;
 130   1              TR1 = 0;                //定时器1开始计时
 131   1      
 132   1              SCON = 0x50; 
 133   1              T2L = (65536 - (FOSC/4/BAUD));   //设置波特率重装值
 134   1          T2H = (65536 - (FOSC/4/BAUD))>>8;
 135   1          AUXR = 0x14;                //T2为1T模式, 并启动定时器2
 136   1          AUXR |= 0x01;               //选择定时器2为串口1的波特率发生器
 137   1         // ES = 1;                     //使能串口1中断
 138   1      
 139   1           IT0 = 1;    //外部中断为边沿触发
 140   1                         //设置INT0的中断类型 (1:仅下降沿 0:上升沿和下降沿)
 141   1           EX0 = 1;  //使能INT0中断
 142   1      
 143   1               IT1=1;
 144   1               EX1=1;//外部中断1 下降沿 中断
 145   1               EA = 1;                 
 146   1      }
 147          /************************************/
 148          void Timer0Interrupt(void) interrupt 1
 149          {                        
 150   1          Time0_flag=1;                  //定时中断标志位置1;
 151   1              TH0=-Pt/256;TL0=-Pt%256;   //设置定时器T0的初设值
 152   1              DISP_LINE++;                    //计数
 153   1      }
 154          /*****主函数*****/
 155          void main(void)
 156          {
 157   1              Init();
 158   1              Send_uart(0x55);
 159   1              
 160   1          //主程序
 161   1              while(1)
 162   1          {           
 163   2              
 164   2                      if(ucMode==2)
 165   2                      {
 166   3                              display_pic();
 167   3                      }
 168   2                       //BIT_timeout=1;
 169   2                      if(BIT_timeout==1)      //起点判断
 170   2                      {                       
 171   3                              BIT_timeout=0; //清零
 172   3                              
 173   3                              Scan_bit=1;// 起点检测到后 LED不再流水测试
 174   3                              if( new_code ) //有红外按键
 175   3                              {
 176   4                                      new_code=0;
 177   4                                      switch( key_code ) //根据不同的按键值执行不同的动作
 178   4                                      {       
 179   5                                         case 0x0C:
C51 COMPILER V9.56.0.0   TASK                                                              06/09/2018 16:09:47 PAGE 4   

 180   5                                              ucMode=0x02;//数字钟模式+侧面文字
 181   5                                      //      TR0 = 1;        
 182   5                                      break;
 183   5      
 184   5                              
 185   5                              
 186   5                                      
 187   5              
 188   5                                              default: break;
 189   5                                      }
 190   4                                      key_code=0;
 191   4                              }
 192   3                      
 193   3                              
 194   3          
 195   3                  
 196   3                      }   
 197   2          
 198   2                      }
 199   1      }
 200          /*********************************************************************************/
 201          /*************************************************************************************
 202          ************************************************************************************
 203          ***********************                                     ***************************
 204          ***********************    http://59tiaoba.taobao.com       ***************************
 205          ***********************                                     ***************************
 206          ************************************************************************************
 207          **********************************************************************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    524    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     15    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
